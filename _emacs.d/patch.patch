diff --git i/_emacs.d/elisp/cppcheck.el w/_emacs.d/elisp/cppcheck.el
deleted file mode 100644
index 7d9ba66..0000000
--- i/_emacs.d/elisp/cppcheck.el
+++ /dev/null
@@ -1,212 +0,0 @@
-(require 'compile)
-
-;;;###autoload
-(defgroup cppcheck nil
-  "*cppcheck"
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-executable "cppcheck"
-  "Path to the cppcheck executable"
-  :type '(file :must-match t)
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-template "{file}:{line}:({severity}): {message}"
-  "Format the error messages. E.g.
-'{file}:{line},{severity},{id},{message}' or
-'{file}({line}):({severity}) {message}'"
-  :type 'string
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-platform nil
-  "Specifies platform specific types and sizes. The
-available platforms are:
-* unix32
-32 bit unix variant
-* unix64
-64 bit unix variant
-* win32A
-32 bit Windows ASCII character encoding
-* win32W
-32 bit Windows UNICODE character encoding
-* win64
-64 bit Windows"
-  :type 'string
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-std-list
-  nil
-  "*Alist of standards to test.
-The available options are:
-* posix
-POSIX compatible code
-* c89
-C code is C89 compatible
-* c99
-C code is C99 compatible
-* c11
-C code is C11 compatible (default)
-* c++03
-C++ code is C++03 compatible
-* c++11
-C++ code is C++11 compatible (default)"
-  :group 'list
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-enable-list
-  all
-  "Enable additional checks. The available ids are:
-* all
-Enable all checks
-* style
-Enable all coding style checks. All messages with the severities 'style', 'performance' and 'portability' are enabled.
-* performance
-Enable performance messages
-* portability
-Enable portability messages
-* information
-Enable information messages
-* unusedFunction
-Check for unused functions
-* missingInclude
-Warn if there are missing includes."
-  :group 'list
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-relative-paths-list
-  nil
-  "Use relative paths in output. When given, <paths> are
-used as base. We use string comparison to create relative
-paths, so using e.g. ~ for home folder does not work. It
-is currently only possible to apply the base paths to
-files that are on a lower level in the directory tree."
-  :group 'list
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-include-path-list
-  nil
-  "*Alist of directories to search for include files."
-  :group 'list
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-hide-configuration-list
-  nil
-  "*Alist of configurations to hide '#ifdef <ID>'"
-  :group 'list
-  :group 'cppcheck)
-
-;;;###autoload
-(defcustom cppcheck-use-configuration-list
-  nil
-  "*Alist of configurations to use '#ifdef <ID>'"
-  :group 'list
-  :group 'cppcheck)
-
-(defun cppcheck-args-get-include-dirs ()
-  "Returns the options for the '-I' flag"
-  (if (and (listp cppcheck-include-path-list) (> (length cppcheck-include-path-list) 0))
-      (let (result)
-        (dolist (element cppcheck-include-path-list)
-          (setq result (if (not (stringp result))
-                           (format " -I %s" element)
-                         (format "%s -I %s" result element)))
-          ) result) ""))
-
-(defun cppcheck-args-get-hidden-configurations ()
-  "Returns the options for the '-U' flag"
-  (if (and (listp cppcheck-hide-configuration-list) (> (length cppcheck-hide-configuration-list) 0))
-      (let (result)
-        (dolist (element cppcheck-hide-configuration-list)
-          (setq result (if (not (stringp result))
-                           (format " -U%s" (shell-quote-argument element))
-                         (format "%s -U%s" result (shell-quote-argument element))))
-          ) result) ""))
-
-(defun cppcheck-args-get-use-configurations ()
-  "Returns the options for the '-U' flag"
-  (if (and (listp cppcheck-use-configuration-list) (> (length cppcheck-use-configuration-list) 0))
-      (let (result)
-        (dolist (element cppcheck-use-configuration-list)
-          (setq result (if (not (stringp result))
-                           (format " -D%s" (shell-quote-argument element))
-                         (format "%s -D%s" result (shell-quote-argument element))))
-          ) result) ""))
-
-(defun cppcheck-args-get-enable ()
-  "Returns the options for the '--enable=' flag"
-  (if (and (listp cppcheck-enable-list) (> (length cppcheck-enable-list) 0))
-      (let (result)
-        (dolist (element cppcheck-enable-list)
-          (setq result (if (not (stringp result))
-                           (format " --enable=%s" element)
-                         (format "%s,%s" result element)))
-          ) result) ""))
-
-(defun cppcheck-args-get-relative-paths ()
-  "Returns the options for the '--relative-paths' flag"
-  (if (and (listp cppcheck-relative-paths-list) (> (length cppcheck-relative-paths-list) 0))
-      (let (result)
-        (dolist (element cppcheck-relative-paths-list)
-          (setq result (if (not (stringp result))
-                           (format " --relative-paths=%s" element)
-                         (format "%s;%s" result element)))
-          ) result) ""))
-
-(defun cppcheck-args-get-std ()
-  "Returns the options for the '--std' flag"
-  (if (and (listp cppcheck-std-list) (> (length cppcheck-std-list) 0))
-      (let (result)
-        (dolist (element cppcheck-std-list)
-          (setq result (if (not (stringp result))
-                           (format " --std=%s" element)
-                         (format "%s --std=%s" result element)))
-          ) result) ""))
-
-(defun cppcheck-get-commandline-args (filename &optional additional-args)
-  "Returns a string containing the a string for running cppcheck based on the various options."
-  (format "%s%s%s%s%s%s%s%s%s%s %s"
-          (shell-quote-argument cppcheck-executable)
-          (cppcheck-args-get-std)
-          (cppcheck-args-get-enable)
-          (cppcheck-args-get-relative-paths)
-          (cppcheck-args-get-include-dirs)
-          (cppcheck-args-get-hidden-configurations)
-          (cppcheck-args-get-use-configurations)
-          (if (stringp cppcheck-platform) (concat " --platform=" cppcheck-platform) "")
-          (if (stringp cppcheck-template) (concat " --template='" cppcheck-template "'") "" )
-          (if (stringp additional-args) (concat " " additional-args) "")
-          filename ))
-
-;;;###autoload
-(define-compilation-mode cppcheck-results-mode "cppcheck"
-  "Sets `cppcheck-last-buffer' and `compilation-window-height'."
-  (setq cppcheck-last-buffer (current-buffer))
-  (set (make-local-variable 'compilation-directory-matcher) '("\\`a\\`"))
-  (set (make-local-variable 'compilation-disable-input) t) )
-
-;;;###autoload
-(defun cppcheck-file (filename &optional additional-args)
-  "Runs cppcheck on the specified file. Additional arguments can be used with the ADDITIONAL-ARGS paramater"
-  (unless (file-exists-p filename) (error (format "cppcheck: File does not exist: %s" filename)))
-  (unless (file-readable-p filename) (error (format "cppcheck: File is not readable: %s" filename)))
-  (compilation-start
-   (cppcheck-get-commandline-args filename additional-args) 'cppcheck-results-mode) )
-
-;;;###autoload
-(defun cppcheck-current-file ()
-  "Runs cppcheck on the current file."
-  (interactive)
-  (cppcheck-file (buffer-file-name)) )
-
-;;;###autoload
-(defun cppcheck-current-file-check-config ()
-  "Runs cppcheck with the '--check-config' option"
-  (interactive)
-  (cppcheck-file (buffer-file-name) "--check-config") )
diff --git i/_emacs.d/elisp/funcs.el w/_emacs.d/elisp/funcs.el
deleted file mode 100644
index b93fdd6..0000000
--- i/_emacs.d/elisp/funcs.el
+++ /dev/null
@@ -1,90 +0,0 @@
-(defun read-hidden-file (file arg)
-  (interactive (list (read-file-name "choose a hidden file: " "~/" nil nil nil
-                                     (lambda (name)
-                                       (string-match "^\\." (file-name-nondirectory name))))
-                     current-prefix-arg))
-  (message "%S, %S" file arg))
-
-(defun tree-mapcar (func tree)
-  (if (consp tree)
-      (mapcar (lambda (child)
-                (tree-mapcar func child))
-              tree)
-    (funcall func tree)))
-
-(defmacro with-inhibit-read-only-t (&rest body)
-  (declare (indent 0) (debug t))
-  (cons 'let (cons '(inhibit-read-only t))
-        body))
-
-(defun show-region (beg end)
-  (interactive
-   (if (or (null transient-mark-mode)
-           mark-active)
-       (list (region-beginning) (region-end))
-     (list (point-min) (point-max))))
-  (message "region start from %d to %d" beg end))
-
-(defun mark-whole-sexp ()
-  (interactive)
-  (let ((bound (bounds-of-thing-at-point 'sexp)))
-    (if bound
-        (progn
-          (goto-char (car bound))
-          (set-mark (point))
-          (goto-char (cdr bound)))
-      (message "no sexp found at point!"))))
-
-;; window related
-(split-window)
-(selected-window)
-(selected-frame)
-(selected-terminal)
-(window-tree)
-
-;;file related
-(with-current-buffer (find-file-noselect "/tmp/test")
-  buffer-file-name)
-
-(find-buffer-visiting "/tmp/test")
-(get-file-buffer "/tmp/test")
-
-(file-modes "/root/.bashrc")
-(format "%o" (file-modes "/tmp"))
-
-(message "%d" most-positive-fixnum)
-
-(require 'calculator)
-(let ((calculator-output-radix 'bin)
-      (calculator-radix-grouping-mode nil))
-  (calculator-number-to-string number))
-
-(defun my-subseq (list from &optional to)
-  (if (null to) (nthcdr from list)
-    (butlast (nthcdr from list) (- (length list) to))))
-
-(defun walk-path (dir action)
-       "walk DIR executing ACTION with (dir file)"
-       (cond ((file-directory-p dir)
-              (or (char-equal ?/ (aref dir(1- (length dir))))
-                  (setq dir (file-name-as-directory dir)))
-              (let ((lst (directory-files dir nil nil t))
-                     fullname file)
-                (while lst
-                  (setq file (car lst))
-                  (setq lst (cdr lst))
-                  (cond ((member file '("." "..")))
-                        (t
-                         (and (funcall action dir file)
-                              (setq fullname (concat dir file))
-                              (file-directory-p fullname)
-                              (walk-path fullname action)))))))
-             (t
-              (funcall action
-                       (file-name-directory dir)
-                       (file-name-nondirectory dir)))))
-    (defun walk-path-visitor (dir file)
-       "Called by walk-path for each file found"
-       (message (concat  dir file)))
-
-    (walk-path "~/" 'walk-path-visitor)
diff --git i/_emacs.d/elisp/lambdacalc.el w/_emacs.d/elisp/lambdacalc.el
deleted file mode 100644
index eff3a13..0000000
--- i/_emacs.d/elisp/lambdacalc.el
+++ /dev/null
@@ -1,544 +0,0 @@
-;;; lambdacalc.el --- Interpret lambda calculus expressions
-
-;; Copyright (C) 2007 Michael Olson
-
-;; Author: Michael Olson (mwolson AT gnu DOT org)
-;; Date: Mon 19-Feb-2007
-;; Version: 1.0
-;; URL: http://mwolson.org/static/dist/elisp/lambdacalc.el
-
-;; This file is not part of GNU Emacs.
-
-;; This is free software; you can redistribute it and/or modify it under
-;; the terms of the GNU General Public License as published by the Free
-;; Software Foundation; either version 2, or (at your option) any later
-;; version.
-;;
-;; This is distributed in the hope that it will be useful, but WITHOUT
-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-;; for more details.
-;;
-;; You should have received a copy of the GNU General Public License
-;; along with GNU Emacs; see the file COPYING.  If not, write to the
-;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-;; Boston, MA 02110-1301, USA.
-
-;;; Commentary:
-
-;; This file provides an interpreter for untyped lambda calculus
-;; expressions.
-
-;; * Use:
-;;
-;; To evaluate a lambda calculus expression, type in the following,
-;; replacing <expression> with the desired expression.
-;;
-;;   M-x lc-eval-expression RET (<expression>) RET
-;;
-;; Note that the expression must be surrounded by a set of
-;; parentheses.  Omit the period in `lambda' constructs.
-;;
-;; To define a metavariable, evaluate the following code, replacing
-;; <varname> with the name of the metavariable, and <expression> with
-;; the desired expression.
-;;
-;;   (lc-def <varname> (<expression>))
-;;
-;; If you wish to evaluate lambda calculus expressions
-;; programmatically, you can use the `lc-eval' macro, which takes
-;; something of the form (<expression>).  There is no need to quote
-;; the expression.
-;;
-;; To see each individual step of the evaluation process, do the
-;; following.  By default, the expressions are pretty-printed; to
-;; change that, customize the `lc-enable-pp' option.
-;;
-;;   M-x lc-step-expression RET (<expression>) RET
-
-;; * Implementation details:
-;;
-;; This interpreter works in several stages.
-;;
-;; ** Translation (Lambda Calculus -> Emacs Lisp):
-;;
-;; The first step is translation from a lambda calculus expression to
-;; an Emacs Lisp expression.  This involves determining bound and free
-;; variables, and replacing implicit function calls with explicit
-;; calls to `lc-apply'.
-;;
-;; ** Evaluation:
-;;
-;; The next step is to evaluate the translated expression, namely:
-;; substituting previously-defined expressions for free variables and
-;; repeatedly applying function calls until a lambda expression is
-;; reached.
-;;
-;; In order to prevent infinite evaluation, a limit has been placed on
-;; the number of consecutive evaluations that are permitted.  The
-;; default is 50.  To change this, customize the `lc-max-steps'
-;; option.
-;;
-;; ** Untranslation (Emacs Lisp -> Lambda Calculus):
-;;
-;; The final step is to take the result from evaluation and make it
-;; look like a lambda calculus expression.  This involves removing the
-;; "bound" and "free" prefixes from variables, removing calls to
-;; `lc-apply', and making the resulting expression as minimal as
-;; possible.
-
-;; * Credits:
-;;
-;; Most of the environment comes from the Types and Programming
-;; Languages textbook by Benjamin C. Pierce.  As far as I can tell,
-;; these sample definitions are considered common knowledge, so I
-;; should be able to distribute them.
-;;
-;; A couple of the functions of the environment are from
-;; <http://www.onebadseed.com/blog/?p=34>, but were modified to use a
-;; single-argument lambda form.
-;;
-;; Thanks go to Riastradh on #emacs for suggesting that I use
-;; functions rather than the macro mess I previously had.
-
-;; * Endorsements:
-;;
-;; From an IRC chat on #hcoop:
-;;
-;;   <mwolson> i'm currently making a lambda calculus interpreter in
-;;             Emacs Lisp
-;;   * Smerdyakov gags. :D
-;;
-;; From an IRC chat on #emacs:
-;;
-;;   * mwolson is tantalizingly close to having the final piece of his
-;;     lambda calculus interpreter (in Emacs Lisp) done
-;;   <forcer> :-)
-;;   <offby1> *shudder*
-
-;;; Code:
-
-(require 'pp)                           ; pretty-printer
-
-;;; Options
-
-(defgroup lc nil
-  "Interpret lambda calculus expressions,"
-  :group 'languages)
-
-(defcustom lc-max-steps 50
-  "Maximum number of steps permitted for evaluation."
-  :type 'integer
-  :group 'lc)
-
-(defcustom lc-enable-pp t
-  "Whether to enable pretty-printing."
-  :type 'boolean
-  :group 'lc)
-
-;;; Helper functions
-
-(defmacro lc-error (msg)
-  "Display the given message as an error message."
-  (list 'error (concat "Lambda calc: " msg)))
-
-;;; Translation (Lambda Calculus -> Emacs Lisp)
-
-(defun lc-bind (sym)
-  "Add prefix to SYM to indicate that it is bound."
-  (intern (concat "lc-bound-" (symbol-name sym))))
-
-(defun lc-sym (bound-syms sym)
-  "If SYM is in BOUND-SYMS, mark it as bound, otherwise free."
-  (if (memq sym bound-syms)
-      (lc-bind sym)
-    (intern (concat "lc-free-" (symbol-name sym)))))
-
-(defun lc-call (bound-syms fun &rest args)
-  "Translate an implicit lambda calc function call to a call to
-the `lc-apply' function."
-  (let ((res nil))
-    (if (not args)
-        (setq res (lc-trans-1 bound-syms fun))
-      (setq res (list 'lc-apply (lc-trans-1 bound-syms fun)
-                      (lc-trans-1 bound-syms (car args))))
-      (dolist (arg (cdr args))
-        (setq res (list 'lc-apply res
-                        (lc-trans-1 bound-syms arg)))))
-    res))
-
-(defun lc-trans-1 (bound-syms exp)
-  "Helper function for `lc-trans'.  Tracks bound symbols."
-  (cond ((atom exp)
-         (if (symbolp exp)
-             (lc-sym bound-syms exp)
-           (lc-error "syntax error")))
-        ((eq (cdr exp) nil)
-         (lc-trans-1 bound-syms (car exp)))
-        ((eq (car exp) 'lambda)
-         (setq bound-syms (cons (cadr exp) bound-syms))
-         (cons 'lambda (cons (list (lc-bind (cadr exp)))
-                             (if (cddr exp)
-                                 (list (lc-trans-1 bound-syms (cddr exp)))
-                               nil))))
-        ((consp (car exp))
-         (apply #'lc-call bound-syms exp))
-        ((symbolp (car exp))
-         (apply #'lc-call bound-syms exp))
-        (t (lc-error "syntax error"))))
-
-(defun lc-trans (exp)
-  "Translate expression EXP into an intermediary Emacs Lisp form."
-  (lc-trans-1 nil exp))
-
-(defmacro lc-def (fun exp)
-  "Define a free variable FUN which evaluates to the expression EXP."
-  (if (not (symbolp fun))
-      (lc-error "invalid definition target")
-    (let ((sym (lc-sym nil fun)))
-      (list 'progn
-            (list 'defvar sym nil)
-            (list 'set `(quote ,sym)
-                  (list 'lc-trans `(quote ,exp)))))))
-
-;;; Untranslation (Emacs Lisp -> Lambda Calculus)
-
-(defun lc-unsym (sym)
-  "Return a new symbol with the bound/free prefix removed from SYM."
-  (intern (replace-regexp-in-string "^lc-\\(free\\|bound\\)-" ""
-                                    (symbol-name sym))))
-
-(defun lc-uncall (exp)
-  "Turn an instance of `lc-apply' back into the corresponding
-lambda calculus expression."
-  (cond ((not (consp exp))
-         (lc-error "syntax error"))
-        ((and (consp (cadr exp))
-              (consp (car (cddr exp))))
-         (nconc (if (eq (car (cadr exp)) 'lc-apply)
-                    (lc-untrans (cadr exp))
-                  (list (lc-untrans (cadr exp))))
-                (list (lc-untrans (car (cddr exp))))))
-        ((consp (cadr exp))
-         (nconc (if (eq (car (cadr exp)) 'lc-apply)
-                    (lc-untrans (cadr exp))
-                  (list (lc-untrans (cadr exp))))
-                (lc-untrans (car (cddr exp)))))
-        ((consp (car (cddr exp)))
-         (nconc (lc-untrans (cadr exp))
-                (list (lc-untrans (car (cddr exp))))))
-        (t (nconc (lc-untrans (cadr exp))
-                  (lc-untrans (car (cddr exp)))))))
-
-(defun lc-untrans (exp)
-  "Turn an intermediary Emacs Lisp form back into a lambda calculus
-expression, using the minimal amount of parentheses."
-  (cond ((atom exp)
-         (if (symbolp exp)
-             (list (lc-unsym exp))
-           (lc-error "syntax error")))
-        ((eq (cdr exp) nil)
-         (lc-untrans (car exp)))
-        ((eq (car exp) 'lambda)
-         (cons 'lambda (cons (lc-unsym (car (cadr exp)))
-                             (if (cddr exp)
-                                 (lc-untrans (car (cddr exp)))
-                               nil))))
-        (t (lc-uncall exp))))
-
-;;; Evaluation
-
-(defun lc-apply-1 (form arg val)
-  "Helper function for `lc-apply'.
-Traverses FORM, replacing ARG with VAL."
-  (cond ((atom form)
-         (if (eq form arg)
-             val
-           form))
-        ((eq (car form) 'lambda)
-         (if (eq (car (cadr form)) arg)
-             form
-           (list 'lambda (cadr form)
-                 (lc-apply-1 (car (cddr form)) arg val))))
-        ((eq (car form) 'lc-apply)
-         (list 'lc-apply
-               (lc-apply-1 (cadr form) arg val)
-               (lc-apply-1 (car (cddr form)) arg val)))
-        (t (lc-error "syntax error during application"))))
-
-(defun lc-apply (form val)
-  "Apply the replacement VAL to FORM."
-  (let ((lc-eval-current-depth (1+ lc-eval-current-depth)))
-    (funcall lc-eval-filter (list 'lc-apply form val))
-    (setq form (lc-eval-1 form))
-    (if (or (atom form) (not (eq (car form) 'lambda)))
-        (lc-error "invalid application")
-      (lc-apply-1 (car (cddr form)) (car (cadr form)) val))))
-
-(defvar lc-eval-filter #'identity
-  "The function to call for each step of evaluation.
-It should take one argument and avoid modifying it.")
-
-(defvar lc-eval-current-depth 0
-  "The depth of the current evaluation step.")
-
-(defun lc-eval-1 (exp)
-  "Helper function for `lc-eval'.
-Evaluates expression EXP until either
-  1. The result is a lambda form.
-  2. The number of evaluation steps exceeds `lc-max-steps'."
-  (let ((steps 0)
-        (lc-eval-current-depth (1+ lc-eval-current-depth)))
-    (while (or (atom exp) (not (eq (car exp) 'lambda)))
-      (when (> steps lc-max-steps)
-        (lc-error "maximum number of eval steps reached"))
-      (funcall lc-eval-filter exp)
-      (setq exp (eval exp))
-      (setq steps (1+ steps)))
-    exp))
-
-(defmacro lc-eval (exp)
-  "Evaluate the lambda calculus expression EXP."
-  (setq exp (lc-trans exp))
-  (let ((lc-eval-filter #'identity))
-    (setq exp (lc-eval-1 exp)))
-  (list 'quote (lc-untrans exp)))
-
-(defun lc-eval-expression (expstring)
-  "Evaluate the lambda calculus expression in string EXPSTRING."
-  (interactive (list (read-string "Lambda calc expression: ")))
-  (let ((exp (macroexpand (list 'lc-eval (read expstring)))))
-    (setq exp (cadr exp))               ; unquote exp
-    (when (interactive-p)
-      (message (format "%s" exp)))
-    exp))
-
-;;; Debugging
-
-(defvar lc-step-buffer nil
-  "Buffer used for the output of `lc-step-eval'.")
-
-(defun lc-pp-expression (header exp)
-  "Pretty-print the expression EXP, using HEADER.
-
-HEADER should be a format string with a single argument.  EXP
-will be formatted according to this string."
-  (let ((blanks (make-string (length (format header ""))
-                             ?\s))
-        (beg (point)))
-    (when lc-enable-pp
-      (setq exp (pp-to-string exp)))
-    (insert (format header exp))
-    (when lc-enable-pp
-      (while (< beg (progn (forward-line 0) (point)))
-        (unless (eolp)
-          (insert blanks))
-        (forward-line -1))
-      (goto-char (point-max)))))
-
-(defun lc-step-eval-filter (exp)
-  "Filter function used to display each step of the evaluation process."
-  (with-current-buffer lc-step-buffer
-    (let ((header (mapconcat #'identity
-                             (make-list (1- lc-eval-current-depth) "    ")
-                             "")))
-      (lc-pp-expression (format "%s  [%s] %%s" header
-                                lc-eval-current-depth)
-                        (lc-untrans exp))
-      (insert "\n")))
-  exp)
-
-(defun lc-step-expression-1 (exp)
-  "Helper function for `lc-step-expression'.
-Shows the steps made throughout the evaluation of the lambda
-calculus expression EXP."
-  (when (buffer-live-p lc-step-buffer)
-    (kill-buffer lc-step-buffer))
-  (setq lc-step-buffer (switch-to-buffer "*LC evaluation*"))
-  (insert "\n")
-  (let ((lc-eval-filter #'lc-step-eval-filter))
-    (lc-pp-expression "  %s"
-                      (lc-untrans (lc-eval-1 (lc-trans exp)))))
-  (insert "\n\nEvaluation finished\n"))
-
-(defun lc-step-expression (expstring)
-  "Evaluate the lambda calculus expression in string EXPSTRING and show
-the steps made while evaluating."
-  (interactive (list (read-string "Lambda calc expression: ")))
-  (lc-step-expression-1 (read expstring)))
-
-;;; Environment
-
-;; Church Booleans
-
-(lc-def tru (lambda t lambda f t))
-(lc-def fls (lambda t lambda f f))
-
-(lc-def test (lambda l lambda m lambda n
-               l m n))
-
-(lc-def and (lambda b lambda c b c fls))
-(lc-def or (lambda b lambda c b tru c))
-(lc-def not (lambda b b fls tru))
-(lc-def if (lambda p lambda a lambda b p a b))
-
-;; Pairs
-
-(lc-def pair (lambda f lambda s lambda b
-               b f s))
-(lc-def fst (lambda p p tru))
-(lc-def snd (lambda p p fls))
-
-;; Church Numerals
-
-(lc-def c0 (lambda s lambda z z))
-(lc-def c1 (lambda s lambda z s z))
-(lc-def c2 (lambda s lambda z s (s z)))
-(lc-def c3 (lambda s lambda z s (s (s z))))
-(lc-def c4 (lambda s lambda z s (s (s (s z)))))
-(lc-def c5 (lambda s lambda z s (s (s (s (s z))))))
-(lc-def c6 (lambda s lambda z s (s (s (s (s (s z)))))))
-
-(lc-def scc (lambda n lambda s lambda z
-              s (n s z)))
-(lc-def plus (lambda m lambda n lambda s lambda z
-               m s (n s z)))
-(lc-def times (lambda m lambda n lambda s
-                m (n s)))
-(lc-def power (lambda m lambda n
-                m n))
-
-(lc-def iszro (lambda m m (lambda x fls) tru))
-
-(lc-def zz (pair c0 c0))
-(lc-def ss (lambda p pair (snd p) (plus c1 (snd p))))
-(lc-def prd (lambda m fst (m ss zz)))
-
-(lc-def subtract (lambda m lambda n n prd m))
-
-(lc-def equal (lambda m lambda n
-                (and (iszro (m prd n))
-                     (iszro (n prd m)))))
-
-;; Utilities
-
-(lc-def identity (lambda x x))
-(lc-def compose (lambda f lambda g lambda x
-                  f (g x)))
-
-;; Lists
-
-;; Pierce's list definitions.  Tail did not evaluate correctly for me.
-;;
-;; (lc-def nil (lambda c lambda n n))
-;; (lc-def isnil (lambda l l (lambda h lambda t fls) tru))
-;; (lc-def cons (lambda h lambda t lambda c lambda n
-;;                c h (t c n)))
-;; (lc-def head (lambda l l (lambda h lambda t h) fls))
-;; (lc-def tail (lambda l
-;;                fst (l (lambda x lambda p
-;;                         pair (snd p) (cons x (snd p)))
-;;                       (pair nil nil))))
-
-;; The following definitions are from the onebadseed.com page.  The
-;; head, tail, and cons forms work, but it does not seem to evaluate
-;; (isnil nil) correctly.
-;;
-;; (lc-def nil (lambda l l identity identity tru))
-;; (lc-def isnil (lambda c
-;;                 (lambda tr lambda fa
-;;                   c (lambda f lambda s lambda t
-;;                       t tr fa))))
-;; (lc-def cons (lambda f lambda s lambda l
-;;                l f s fls))
-;; (lc-def head (lambda c c (lambda f lambda s lambda t f)))
-;; (lc-def tail (lambda c c (lambda f lambda s lambda t s)))
-
-;; The following is the "rather different approach" from Pierce's
-;; text.  It was able to handle all of the test cases I threw at it,
-;; so I went with it.
-
-(lc-def nil (pair tru tru))
-(lc-def isnil fst)
-(lc-def cons (lambda h lambda t
-               pair fls (pair h t)))
-(lc-def head (lambda z fst (snd z)))
-(lc-def tail (lambda z snd (snd z)))
-
-;; Recursion
-
-(lc-def omega ((lambda x x x) (lambda x x x)))
-(lc-def fix (lambda f
-              (lambda x f (lambda y x x y))
-              (lambda x f (lambda y x x y))))
-
-;; Sample functions
-
-(lc-def factorial
-        (fix (lambda f lambda n
-               (test (iszro n)
-                     (lambda x c1)
-                     (lambda x (times n (f (prd n)))))
-               ;; dummy argument
-               tru)))
-
-;; Does not seem to work; need to test this at some point.
-;;
-;; (lc-def sumlist (lambda l l plus c0))
-
-(lc-def sumlist
-        (fix (lambda f lambda l
-               (test (isnil l)
-                     (lambda x c0)
-                     (lambda x (plus (head l) (f (tail l)))))
-               tru)))
-
-;;; Test cases
-
-(defmacro lc-test (test result)
-  "Make sure that the lambda calculus expression TEST yields the
-lambda calculus expression RESULT, when both are evaluated.
-
-If they do not yield the same value, throw 'test-field with a
-cons of the test and the desired result."
-  `(if (equal (lc-eval ,test)
-              (lc-eval ,result))
-       t
-     (throw 'test-failed (cons ',test ',result))))
-
-(defun lc-consistency-check ()
-  "Perform various tests to make sure the evaluator and
-environment work as expected."
-  (interactive)
-  (let ((err nil))
-    (if (setq err
-              (catch 'test-failed
-                ;; lists
-                (lc-test (equal (head (cons c1 c2)) c1)
-                         tru)
-                (lc-test (equal (head (cons c1 c2)) c2)
-                         fls)
-                (lc-test (equal (tail (cons c1 c2)) c1)
-                         fls)
-                (lc-test (equal (tail (cons c1 c2)) c2)
-                         tru)
-                (lc-test (equal (head (cons c3 (cons c1 c2))) c3)
-                         tru)
-                (lc-test (equal (head (cons c3 (cons c1 c2))) c1)
-                         fls)
-                (lc-test (equal (tail (cons c3 (cons c1 c2))) (cons c1 c2))
-                         tru)
-                (lc-test (isnil nil)
-                         tru)
-                (lc-test (isnil (cons nil nil))
-                         fls)
-                (lc-test (isnil (cons c0 c1))
-                         fls)
-                nil))
-        (message "Consistency check for %s failed: expected %s"
-                 (car err) (cdr err))
-      (message "Consistency checks passed"))))
-
-(provide 'lambdacalc)
-
-;;; lambdacalc.el ends here
diff --git i/_emacs.d/elisp/latex-preview-pane.el w/_emacs.d/elisp/latex-preview-pane.el
deleted file mode 100755
index 0ab86fe..0000000
--- i/_emacs.d/elisp/latex-preview-pane.el
+++ /dev/null
@@ -1,44 +0,0 @@
-(defcustom pdf-latex-command "pdflatex" "pdflatex command"
-  :group 'preview)
-
-(if (eq window-system 'w32) (setq view-buffer-command "start")
- (if (eq system-type 'gnu/linux) (setq view-buffer-command "open"))) 
-
-(if (eq window-system 'w32) (setq view-buffer-command "start")
-  (cond ((eq system-type 'gnu/linux) (setq view-buffer-command "xdg-open"))
-        ((eq system-type 'darwin) (setq view-buffer-command "open"))
-        (t (setq view-buffer-command "xdg-open"))))
-
-(defun latex-preview-update ()
-  (interactive)
-  (if (eq (call-process pdf-latex-command nil "*pdflatex-buffer*" nil buffer-file-name) 1)
-      (if (y-or-n-p "PDF Generation Failed. View Errors?") (switch-to-buffer "*pdflatex-buffer*"))
-    (start-process "Preview"
-                   (get-buffer-create "*pdflatex-buffer*")
-                   view-buffer-command
-                   (replace-regexp-in-string ".tex" ".pdf" buffer-file-name)
-                   )))
-
-(defun latex-preview-pane-update ()
-  (interactive)
-  (when (eq major-mode 'latex-mode)
-    (progn
-      (message "Updating LaTeX Preview Pane")
-      (latex-preview-pane-update-p))))
-
-(defun latex-preview-pane-update-p ()
-  (if (eq (call-process pdf-latex-command nil "*pdflatex-buffer*" nil buffer-file-name) 1)
-      (if (y-or-n-p "PDF Generation Failed. View Errors?") (switch-to-buffer "*pdflatex-buffer*"))
-    (let ((tex-buff (current-buffer))
-          (pdf-buff (replace-regexp-in-string ".tex" ".pdf" (buffer-file-name))))
-
-      (if (not (eq (get-buffer-window pdf-buff) nil))
-          (progn
-            (switch-to-buffer-other-window pdf-buff)
-            (switch-to-buffer-other-window tex-buff)
-            )
-        ))))
-
-(add-hook 'after-save-hook 'latex-preview-pane-update)
-
-(provide 'latex-preview-pane)
diff --git i/_emacs.d/elisp/magic-buffer/.gitignore w/_emacs.d/elisp/magic-buffer/.gitignore
deleted file mode 100644
index 293232b..0000000
--- i/_emacs.d/elisp/magic-buffer/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/libpeerconnection.log
diff --git i/_emacs.d/elisp/magic-buffer/README.md w/_emacs.d/elisp/magic-buffer/README.md
deleted file mode 100644
index 635e82b..0000000
--- i/_emacs.d/elisp/magic-buffer/README.md
+++ /dev/null
@@ -1,27 +0,0 @@
-# magic-buffer
-An executable cookbook, on how to (ab)use emacse's display engine. Feel free to add sections, or suggest improvements.
-
-![screenshot](https://github.com/sabof/magic-buffer/raw/master/screenshot.png)
-
-## Trans-network autoload
-You can add the following snippet to your .emacs. It will download and install the latest version of magic-buffer on its firsts run.
-
-    (defun magic-buffer ()
-      (interactive)
-      (let (( file-name
-              (concat temporary-file-directory
-                      "magic-buffer.el"))
-            ( try-downloading
-              (lambda ()
-                (url-copy-file
-                 "https://raw.github.com/sabof/magic-buffer/master/magic-buffer.el"
-                 file-name t)
-                (require 'magic-buffer file-name))))
-        (condition-case nil
-            (funcall try-downloading)
-          (error (funcall try-downloading))))
-      (magic-buffer))
-
-then
-
-    M-x magic-buffer
diff --git i/_emacs.d/elisp/magic-buffer/lady-with-an-ermine.jpg w/_emacs.d/elisp/magic-buffer/lady-with-an-ermine.jpg
deleted file mode 100644
index cadf72a..0000000
Binary files i/_emacs.d/elisp/magic-buffer/lady-with-an-ermine.jpg and /dev/null differ
diff --git i/_emacs.d/elisp/magic-buffer/magic-buffer.el w/_emacs.d/elisp/magic-buffer/magic-buffer.el
deleted file mode 100644
index 2c9b37e..0000000
--- i/_emacs.d/elisp/magic-buffer/magic-buffer.el
+++ /dev/null
@@ -1,971 +0,0 @@
-;;; magic-buffer.el --- -*- lexical-binding: t -*-
-;;; Version: 0.1
-;;; Author: sabof
-;;; URL: https://github.com/sabof/magic-buffer
-
-;;; Commentary:
-
-;; The project is hosted at https://github.com/sabof/magic-buffer
-;; The latest version, and all the relevant information can be found there.
-;;
-;; Some sections have comments such as this:
-;;
-;;     (info "(elisp) Pixel Specification")
-;;
-;; If you place the cursor in the end, and press C-x C-e, it will take you to
-;; the related info page.
-
-;;; License:
-
-;; This file is NOT part of GNU Emacs.
-;;
-;; This program is free software; you can redistribute it and/or
-;; modify it under the terms of the GNU General Public License as
-;; published by the Free Software Foundation; either version 2, or (at
-;; your option) any later version.
-;;
-;; This program is distributed in the hope that it will be useful, but
-;; WITHOUT ANY WARRANTY; without even the implied warranty of
-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-;; General Public License for more details.
-;;
-;; You should have received a copy of the GNU General Public License
-;; along with this program ; see the file COPYING.  If not, write to
-;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-;; Boston, MA 02111-1307, USA.
-
-;;; Code:
-
-(require 'cl-lib)
-(require 'color)
-(require 'info) ; For title faces
-
-;;; * Library ------------------------------------------------------------------
-;; Functions potentially useful in other contexts
-
-(defun mb-in-range (number from to)
-  "Test whether a number is in FROM \(inclusive\) TO \(exclusive\) range."
-  (and (<= from number) (< number to)))
-
-(defun mb-table-asciify-char (char)
-  "Convert UTF8 table characters to their ASCII equivalents.
-If a character is not a table character, it will be left unchanged."
-  ;; All table characters belong to the range 9472 inclusive - 9600 exclusive,
-  ;; The comment contains the first character of each range
-  (cond ( (mb-in-range char 9472 9474) ?-) ; ─
-        ( (mb-in-range char 9474 9476) ?|) ; │
-        ( (mb-in-range char 9476 9478) ?-) ; ┄
-        ( (mb-in-range char 9478 9480) ?|) ; ┆
-        ( (mb-in-range char 9480 9482) ?-) ; ┈
-        ( (mb-in-range char 9482 9484) ?|) ; ┊
-        ( (mb-in-range char 9484 9500) ?-) ; ┌
-        ( (mb-in-range char 9500 9508) ?|) ; ├
-        ( (mb-in-range char 9508 9516) ?|) ; ┤
-        ( (mb-in-range char 9516 9524) ?-) ; ┬
-        ( (mb-in-range char 9524 9532) ?-) ; ┴
-        ( (mb-in-range char 9532 9548) ?+) ; ┼
-        ( (mb-in-range char 9548 9550) ?-) ; ╌
-        ( (mb-in-range char 9550 9552) ?|) ; ╎
-        ( (member char '(?═ ?╒ ?╔ ?╕ ?╗ ?╘ ?╚ ?╛ ?╝))    ?=)
-        ( (member char '(?║ ?╓ ?╖ ?╙ ?╜))                ?-)
-        ( (member char '(?╞ ?╠ ?╡ ?╣ ?╤ ?╦ ?╧ ?╩ ?╪ ?╬)) ?=)
-        ( (member char '(?╟ ?╢ ?╥ ?╨ ?╫))                ?-)
-        ( (member char '(?╭ ?╯ ?╱))                      ?/)
-        ( (member char '(?╮ ?╰ ?╲))   (string-to-char "\\"))
-        ( (= char ?╳) ?X)
-        ( (mb-in-range char 9588 9600)
-          (if (cl-evenp char) ?- ?|))
-        ( t char)))
-
-(defun mb-table-asciify-string (string)
-  "Convert an UTF8 table to an ASCII table.
-Accepts two numeric arguments, and will replace charactres in the
-the corresponding region of the buffer."
-  (cl-loop for char across string
-           collect (or (mb-table-asciify-char char)
-                       char)
-           into char-list
-           finally return (apply 'string char-list)))
-
-(defun mb-table-asciify-region (from to)
-  (save-excursion
-    (goto-char from)
-    (insert-and-inherit
-     (mb-table-asciify-string
-      (delete-and-extract-region from to)))))
-
-(defun mb-table-insert (string)
-  "Insert a table with UTF8 table borders, replacing them with ASCII
-fallbacks, if needed."
-  (let ((start-pos (point))
-        end-pos)
-    (condition-case error
-        (progn
-          (cl-loop for char across string
-                   do
-                   (cl-assert (char-displayable-p char)))
-          (insert (propertize
-                   string
-                   'face '(:height 2.0 :family "DejaVu Sans Mono")
-                   ))
-          (setq end-pos (point))
-          (goto-char start-pos)
-          (let (( regions
-                  (mapcar 'car (mb-region-pixel-dimensions-multiple
-                                (cl-loop while (< (point) end-pos)
-                                         collecting (cons (point) (line-end-position))
-                                         until (cl-plusp (forward-line)))))))
-            (cl-assert (cl-every (apply-partially '= (car regions))
-                                 regions)))
-          (goto-char end-pos))
-      (error (mb-table-asciify-region
-              start-pos end-pos)
-             ))))
-
-(defun mb-random-hex-color ()
-  (apply 'format "#%02X%02X%02X"
-         (mapcar 'random (make-list 3 255))))
-
-(defmacro mb-with-adjusted-enviroment (&rest body)
-  (declare (indent defun))
-  `(save-excursion
-     (cond ( (get 'mb-with-adjusted-enviroment 'active)
-             ,@body)
-           ( (eq (current-buffer) (window-buffer))
-             (let (( initial-start (window-start)))
-               ad-do-it
-               (set-window-start nil inital-start)))
-           ( t (unwind-protect
-                   (save-window-excursion
-                     (set-window-buffer nil (current-buffer))
-                     (put 'mb-with-adjusted-enviroment 'active t)
-                     ,@body)
-                 (put 'mb-with-adjusted-enviroment 'active nil))))))
-
-(defun mb-posn-at-point (&optional pos)
-  (unless pos
-    (setq pos (point)))
-  (mb-with-adjusted-enviroment
-    (goto-char pos)
-    (or (nth 2 (posn-at-point pos))
-        (progn
-          (goto-char (line-beginning-position))
-          (set-window-start nil (point))
-          (goto-char pos)
-          (nth 2 (posn-at-point pos))))))
-
-(defun mb-region-pixel-dimensions-multiple (alist)
-  (let* (( alist (copy-tree alist))
-         ( sorted-alist
-           (cl-sort (copy-sequence alist) '< :key 'car))
-         before after)
-    (mb-with-adjusted-enviroment
-      (cl-loop for cons in sorted-alist
-               with to = (mb-posn-at-point (car cons))
-               with from = (mb-posn-at-point (cdr cons))
-               do (progn (setcar cons (abs (- (car from) (car to))))
-                         (setcdr cons (abs (- (cdr from) (cdr to)))))
-               finally return alist))))
-
-(defun mb-region-pixel-dimensions (from to)
-  "Find a region's pixel "
-  (let (( from (mb-posn-at-point from))
-        ( to (mb-posn-at-point to)))
-    (cons (abs (- (car from) (car to)))
-          (abs (- (cdr from) (cdr to))))))
-
-(defun mb-window-inside-pixel-width (&optional window)
-  (setq window (window-normalize-window window))
-  (let (( window-pixel-edges (window-inside-pixel-edges)))
-    (- (nth 2 window-pixel-edges) (nth 0 window-pixel-edges))))
-
-(defun mb-window-inside-pixel-height (&optional window)
-  (setq window (window-normalize-window window))
-  (let (( window-pixel-edges (window-inside-pixel-edges)))
-    (- (nth 3 window-pixel-edges) (nth 1 window-pixel-edges))))
-
-(defun mb-align-variable-width (&optional right)
-  (mb-with-adjusted-enviroment
-    ;; Add protection against negative aligmnets
-    (beginning-of-visual-line)
-    (let* (( beginning-of-visual-line)
-           ( end-of-visual-line
-             (save-excursion
-               (end-of-visual-line)
-               (point)))
-           ( region (list (point)
-                          (if (= (line-end-position) end-of-visual-line)
-                              (line-end-position)
-                              ;; FIXME: This makes the line one char narrower than it is
-                              (max (point-min) (1- end-of-visual-line)))))
-           ( pixel-width (car (apply 'mb-region-pixel-dimensions region)))
-           ( align-spec (if right
-                            ;; Full-width lines will break, when word-wrap is
-                            ;; enabled. That's why I substract one pixel in the
-                            ;; end. See:
-                            ;; http://debbugs.gnu.org/cgi/bugreport.cgi?2749
-                            `(space :align-to (- right (,pixel-width) (1)))
-                            `(space :align-to (- center (,(/ pixel-width 2)))))))
-      (if (= (point) (line-beginning-position))
-          (if (looking-at "[\t ]+")
-              (put-text-property
-               (match-beginning 0)
-               (match-end 0)
-               'display align-spec)
-              (put-text-property
-               (line-beginning-position)
-               (line-end-position)
-               'line-prefix (propertize " " 'display align-spec)))
-          (if (looking-at "[\t ]+")     ; in the middle of a logical line
-              ;; In some cases, when a line is almost equal to the window's
-              ;; width, and it ends with an align-to spec, it will belong to the
-              ;; next line, while being centered to the previous, resulting in
-              ;; that character's disappearance.
-              ;;
-              ;; Or something like that. Might try to reproduce it later.
-              (if right
-                  (put-text-property
-                   (match-beginning 0)
-                   (match-end 0)
-                   'display
-                   `(space :width (,(- (mb-window-inside-pixel-width) pixel-width))))
-                  (put-text-property
-                   (match-beginning 0)
-                   (match-end 0)
-                   'display
-                   `(space :width (,(/ (- (mb-window-inside-pixel-width) pixel-width)
-                                       2)))))
-              (put-text-property
-               (1- (point))
-               (min (1+ (point)) (point-max))
-               'wrap-prefix (propertize " " 'display align-spec))))
-      ;; Frame width 65
-      ;; (error "test")
-      pixel-width
-      )))
-
-(defun mb-delete-subsequence (from to list)
-  (let (( after-to (nthcdr to list)))
-    (if (zerop from)
-        after-to
-        (progn
-          (setcdr (nthcdr (1- from) list) after-to)
-          list))))
-
-(defun mb-plist-remove-key (key plist)
-  (let ((pos (cl-position key plist)))
-    (if pos
-        (mb-delete-subsequence
-         pos (+ 2 pos) plist)
-        plist)))
-
-(defun mb-show-in-two-columns (outer-margins inner-border rows)
-  (cl-dolist (row rows)
-    (insert (propertize " " 'display `(space :align-to ,outer-margins))
-            (car row)
-            (apply 'propertize " "
-                   'display `(space :align-to (- center (,inner-border . 0.5)))
-                   (mb-plist-remove-key
-                    'display (text-properties-at
-                              0 (car row))))
-            (propertize " "
-                        'display `(space :width ,inner-border)
-                        )
-            (nth 1 row)
-            (apply 'propertize " "
-                   'display `(space :align-to (- right ,outer-margins))
-                   (mb-plist-remove-key
-                    'display (text-properties-at
-                              0 (nth 1 row))))
-            (apply 'propertize "\n" (car (last row))))))
-
-(defun mb-content-height ()
-  (let (added-newline)
-    (mb-with-adjusted-enviroment
-      (with-silent-modifications
-        (set-window-start nil (point-min))
-        (goto-char (point-max))
-        (unless (or (equal (char-before) ?\n )
-                    (= (point-min) (point-max)))
-          (insert "\n")
-          (setq added-newline t))
-        (prog1 (cdr (nth 2 (posn-at-point)))
-          (when added-newline
-            (delete-char -1)))
-        ))))
-
-(defvar mb-centerv nil)
-
-(cl-defun mb--recenter-buffer-vertically (&optional dont-recenter)
-  (let (content-height
-        ( window-height (mb-window-inside-pixel-height))
-        ( inhibit-read-only t)
-        ov)
-    (save-excursion
-      (mapc 'delete-overlay
-            (cl-remove-if-not
-             (lambda (ov)
-               (and (overlay-get ov 'mb-centerer)
-                    (eq (overlay-get ov 'window)
-                        (selected-window))))
-             (overlays-at (point-min))))
-      (unless (setq content-height (mb-content-height))
-        (cl-return-from mb--recenter-buffer-vertically nil))
-      (unless (get-text-property (point-min) 'mb-centerer)
-        (with-silent-modifications
-          (goto-char (point-min))
-          (insert (propertize " " 'mb-centerer t ;; 'invisible t
-                              'rear-nonsticky '( ;; invisible
-                                                ;; read-only
-                                                mb-centerer)))))
-      (progn
-        (setq ov (make-overlay
-                  (point-min)
-                  (min (point-max)
-                       (1+ (point-min)))))
-        (overlay-put ov 'mb-centerer t)
-        (overlay-put ov 'read-only t)
-        (overlay-put ov 'window (selected-window))
-        (overlay-put ov 'display
-                     (if content-height
-                         (propertize "\n"
-                                     'line-height
-                                     (/ (- window-height
-                                           content-height) 2))
-                         (propertize "\n" 'invisible t))))
-      (unless dont-recenter
-        (set-window-start nil (point-min))))))
-
-(cl-defun mb-center-buffer-vertically (&optional (buffer (current-buffer)))
-  "Inserts a newline character in the beginning of the buffer,
-displayed in a way that will make the buffer appear vertically
-centered. Not meant to be used in \"writing\" buffers, where
-undo history is important."
-  (with-current-buffer buffer
-    (add-hook 'window-configuration-change-hook
-              'mb--recenter-buffer-vertically
-              nil t)
-    (add-hook 'post-command-hook
-              'mb--recenter-buffer-vertically
-              nil t)
-    (add-hook 'window-scroll-functions
-              (lambda (&rest ignore)
-                (mb--recenter-buffer-vertically t))
-              nil t)
-    ;; (add-hook 'window-scroll-functions 'mb--recenter-buffer nil t)
-    ))
-
-;;; * Helpers ------------------------------------------------------------------
-;; Utilities that make this presentation possible
-
-(defvar mb-sections nil)
-(setq mb-sections nil)
-(defvar mb-counter 1)
-(setq mb-counter 1)
-
-(defvar mb--exclusive-section nil
-  "Only show the section with a particular number.
-Created to ease development.")
-(defvar mb-expamle-image
-  (or (and load-file-name
-           (file-exists-p
-            (concat
-             (file-name-directory load-file-name)
-             "lady-with-an-ermine.jpg"))
-           (concat
-            (file-name-directory load-file-name)
-            "lady-with-an-ermine.jpg"))
-      (and buffer-file-name
-           (file-exists-p
-            (concat
-             (file-name-directory buffer-file-name)
-             "lady-with-an-ermine.jpg"))
-           (concat
-            (file-name-directory buffer-file-name)
-            "lady-with-an-ermine.jpg"))
-      (let (( file-name
-              (concat temporary-file-directory
-                      "lady-with-an-ermine.jpg")))
-        (url-copy-file
-         "https://raw.github.com/sabof/magic-buffer/master/lady-with-an-ermine.jpg"
-         file-name t)
-        file-name)))
-
-(defmacro mb-section (name &rest body)
-  (declare (indent defun))
-  `(let* (( cons (car (push (list (prog1 mb-counter
-                                    (cl-incf mb-counter)))
-                            mb-sections))))
-     (setcdr cons (list ,name
-                        ,(if (stringp (car body))
-                             (pop body)
-                             nil)
-                        (lambda ()
-                          ,@body)))))
-
-(defun mb-insert-filled (string)
-  (let ((beginning (point)))
-    (insert string)
-    (fill-region beginning (point))))
-
-(defun mb-subsection-header (string)
-  (insert "\n" (propertize string 'face 'info-title-4) "\n\n"))
-
-(defun mb-comment (string)
-  (mb-insert-filled (propertize string 'face 'font-lock-comment-face))
-  (insert "\n"))
-
-(defmacro mb-insert-info-links (&rest links)
-  `(progn
-     (delete-char -1)
-     ,@(mapcar (lambda (link)
-                 `(progn
-                    (insert-text-button ,(cadr link) 'action
-                                        (lambda (e) (info ,(cadr link))))
-                    (insert (propertize " | " 'face 'bold))))
-               links)
-     (delete-char -3)
-     (insert "\n")))
-
-;;; * Sections ------------------------------------------------------------------
-
-(mb-section "Horizontal line"
-  "The point-entered property prevents the point from staying on that location,
-since that would change the color of the line."
-  (insert (propertize
-           "\n"
-           'display `(space :align-to (- right (1)))
-           'face '(:underline t)
-           'point-entered (lambda (old new)
-                            (forward-line
-                             (if (< old new) 1 -1)))
-           ))
-  (insert "\n"))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Stipples / 2 columns / Line cursor"
-  "Uses stipples that come with your unix distribution. I'll add
-a cutsom stipple example later. They have some re-drawing issues after scrolling."
-  (let ((ori-point (point))
-        grid-strings stipple-names)
-    (cl-dolist (dir x-bitmap-file-path)
-      (setq stipple-names
-            (nconc
-             stipple-names
-             (cl-remove-if (lambda (file) (member file '(".." ".")))
-                           (directory-files dir)))))
-    (setq stipple-names
-          (sort stipple-names
-                (lambda (&rest ignore)
-                  (zerop (random 2)))))
-    (setq stipple-names
-          (last stipple-names 12))
-    (while stipple-names
-      (let* (( current-batch
-               (list (pop stipple-names)
-                     (pop stipple-names))))
-        (push (nconc (mapcar
-                      (lambda (name)
-                        (if (not name)
-                            " "
-                            (propertize name 'face
-                                        '(:weight
-                                          bold
-                                          :inherit variable-pitch))))
-                      current-batch)
-                     (list (list 'line-height 2.0)))
-              grid-strings)
-        (push (nconc (mapcar (lambda (stipple)
-                               (if (not stipple)
-                                   " "
-                                   (propertize " "
-                                               'face
-                                               `(:inherit
-                                                 font-lock-comment-face
-                                                 :stipple ,stipple))))
-                             current-batch)
-                     (list (list 'line-height 2.0)))
-              grid-strings)))
-    (setq tmp (length grid-strings))
-    (setq grid-strings (nreverse grid-strings))
-    (mb-show-in-two-columns 4 2 grid-strings)
-    (backward-char)
-    (setq-local face-remapping-alist
-                `((hl-line (:background
-                            ,(apply 'format "#%02X%02X%02X"
-                                    (mapcar (apply-partially '* 255)
-                                            (color-complement
-                                             (face-attribute 'cursor :background))))
-                            :inverse-video t))))
-    (add-text-properties ori-point (point)
-                         (list 'point-entered (lambda (&rest ignore)
-                                                (setq cursor-type nil)
-                                                (hl-line-mode))
-                               'point-left (lambda (&rest ignore)
-                                             (setq cursor-type t)
-                                             (hl-line-mode -1))))))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Differentiate displays"
-  (mb-insert-info-links
-   (info "(elisp) Defining Faces")
-   (info "(elisp) Display Feature Testing"))
-  (insert "\n")
-  (defface mb-diff-terminal
-    '(( ((type graphic))
-        (:background "DarkRed"))
-
-      ( ((class color)
-         (min-colors 88))
-        (:background "blue"))
-
-      ( ((class color)
-         (min-colors 88))
-        (:background "green"))
-
-      ( t (:background "gray")
-          ))
-    "a test face")
-
-  (mb-insert-filled
-   (propertize "This text will have a different background, depending on \
-   the type of display (Graphical, tty, \"full color\" tty)."
-               'face 'mb-diff-terminal))
-  (insert "\n"))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Differentiate windows"
-  (mb-insert-info-links
-   (info "(elisp) Overlay Properties"))
-  (insert "\n")
-  (let (( text "This text will have a different background color in each \
-  window it is displayed")
-        ( window-list (list 'window-list))
-        ( point-a (point))
-        point-b)
-    (insert text)
-    (setq point-b (point))
-    (add-hook 'window-configuration-change-hook
-              (lambda (&rest ignore)
-                (cl-dolist (win (get-buffer-window-list nil nil t))
-                  (unless (assoc win (cdr window-list))
-                    (let ((ov (make-overlay point-a point-b)))
-                      (setcdr window-list (cl-acons win ov (cdr window-list)))
-                      (overlay-put ov 'window win)
-                      (overlay-put ov 'face
-                                   `(:background
-                                     ,(mb-random-hex-color))))
-                    )))
-              nil t)))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Aligning fixed width text"
-  (mb-insert-info-links
-   (info "(elisp) Pixel Specification"))
-  (mb-comment "The alignment will persist on window resizing, unless the window is narrower
-than the text.")
-  (let* (( text-lines (split-string "Lorem ipsum dolor sit amet
-Sed bibendum
-Curabitur lacinia pulvinar nibh
-Nam euismod tellus id erat
-Sed diam
-Phasellus at dui in ligula mollis ultricies"
-                                    "\n")))
-    (mb-subsection-header "Center")
-    (cl-dolist (text text-lines)
-      (let ((spec `(space :align-to (- center ,(/ (length text) 2)))))
-        (insert  (propertize text 'line-prefix
-                             (propertize " " 'display spec))
-                 "\n")))
-
-    (mb-subsection-header "Right")
-    (cl-dolist (text text-lines)
-      (let ((spec `(space :align-to (- right ,(length text) (1)))))
-        (insert  (propertize text 'line-prefix
-                             (propertize " " 'display spec))
-                 "\n"))))
-
-  (mb-subsection-header "Display on both sides of the window")
-  (let* (( text-left "LEFT --")
-         ( text-right "-- RIGHT")
-         ;; There is an off-by one bug. When word-wrap is enabled, the line will
-         ;; break. That's why I substract one pixel in the end. This will show
-         ;; up as a single empty character on terminals.
-         ( spec `(space :align-to (- right ,(length text-right) (1)))))
-    (insert text-left)
-    (insert (propertize " " 'display spec))
-    (insert text-right)
-    ))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Aligning variable width text"
-  (mb-insert-info-links
-   (info "(elisp) Pixel Specification"))
-  (mb-comment "Will break, should the size of frame's text
-change. If there are line breaks, the lines won't align after a
-window resize. There might be a better way to do right
-alignement, using bidi text support. *WIP*")
-  (let* (( paragraphs "Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
-Pellentesque dapibus ligula
-Proin neque massa, eget, lacus
-Curabitur vulputate vestibulum lorem")
-         end)
-    (mb-subsection-header "Center")
-    (save-excursion
-      (cl-loop for text in (split-string paragraphs "\n")
-               for height = 2.0 then (- height 0.4)
-               for face-spec = `(:inherit variable-pitch :height ,height)
-               do (insert (propertize text 'face face-spec) "\n"))
-      (setq end (point)))
-    ;; (vertical-motion) seems to misbehave when
-    ;;
-    ;;     (not (eq (current-buffer) (window-buffer)))
-    ;;
-    ;; (mb-with-adjusted-enviroment) ensures that the buffer is displayed. It
-    ;; also reduces multiple (save-window-excurson)s to one.
-    (mb-with-adjusted-enviroment
-      (cl-loop while (< (point) end)
-               do
-               (mb-align-variable-width)
-               (unless (cl-plusp (vertical-motion 1))
-                 (return))))
-
-    (goto-char (point-max))
-    (mb-subsection-header "Right")
-    (cl-loop for text in (split-string paragraphs "\n")
-             for height = 1.0 then (+ height 0.4)
-             do (let (( ori-point (point))
-                      ( face-spec  `(:inherit variable-pitch :height ,height)))
-                  (insert (propertize text 'face face-spec))
-                  ;; (goto-char ori-point)
-                  (mb-align-variable-width 'right)
-                  (insert "\n")
-                  ))
-    ;; Fails with
-    ;; (set-frame-width nil 52)
-    )
-  )
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Re-align after variable-width font lines"
-  "Similar to what `fill-column-indicator' does. A similar effect
-can be achieved by setting `tab-width' to a large number, and
-splitting columns with tabs, but this will affect tabs in the
-whole buffer. The red line will move further to the right,
-should the preceeding text be long."
-  (let* (( sentances (split-string
-                      "Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
-Donec hendrerit tempor tellus.
-Donec pretium posuere tellus.
-Proin quam nisl, tincidunt et, mattis eget, convallis nec, purus.
-Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.
-Nulla posuere.
-Donec vitae dolor.
-Nullam tristique diam non turpis.
-Cras placerat accumsan nulla.
-Nullam rutrum.
-Nam vestibulum accumsan nisl."
-                      "\n"))
-         ( spec `(space :align-to 80)))
-    (cl-dolist (sentance sentances)
-      (insert (propertize sentance 'face `(:inherit
-                                           variable-pitch
-                                           :height ,(+ 1.0 (/ (random 10) 10.0))))
-              (propertize " " 'display spec)
-              (propertize " " 'face '(:background "red")
-                          'display '(space :width (2)))
-              " More text"
-              "\n"))))
-
-;; -----------------------------------------------------------------------------
-
-;; (mb-section "Center horizontally and vertically"
-;;   (insert-button "Show in new buffer"
-;;                  'action (lambda (e)
-;;                            (switch-to-buffer
-;;                             (get-buffer-create
-;;                              "*magic-buffer-hv-centering*"))
-;;                            (let ((inhibit-read-only t))
-;;                              (erase-buffer)
-;;                              (insert "test")
-;;                              (mb-center-line-variable-width))
-;;                            (unless view-mode
-;;                              (view-mode 1))
-;;                            ))
-;;   )
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Extra leading"
-  "The line-height property only has effect when applied to newline characters."
-  (insert (propertize "Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
-Integer placerat tristique nisl.
-Aenean in sem ac leo mollis blandit.
-Nunc eleifend leo vitae magna.
-"
-                      'line-height 1.5
-                      )))
-;; -----------------------------------------------------------------------------
-
-(mb-section "Utf-8 tables"
-  "Some fonts don't support box characters well, for example the
-widths might be different. For those cases an ASCII fallback is
-provided. If you know which widely used fonts apart from
-\"DejaVu Sans Mono\" render correctly, please let me know.
-
-Spaces might appear between characters, especially with smaller font sizes.
-
-A table of unicode box characters can be found in the source code."
-
-  ;; ─ ━ │ ┃ ┄ ┅ ┆ ┇ ┈ ┉ ┊ ┋ ┌ ┍ ┎ ┏
-
-  ;; ┐ ┑ ┒ ┓ └ ┕ ┖ ┗ ┘ ┙ ┚ ┛ ├ ┝ ┞ ┟
-
-  ;; ┠ ┡ ┢ ┣ ┤ ┥ ┦ ┧ ┨ ┩ ┪ ┫ ┬ ┭ ┮ ┯
-
-  ;; ┰ ┱ ┲ ┳ ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻ ┼ ┽ ┾ ┿
-
-  ;; ╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╌ ╍ ╎ ╏
-
-  ;; ═ ║ ╒ ╓ ╔ ╕ ╖ ╗ ╘ ╙ ╚ ╛ ╜ ╝ ╞ ╟
-
-  ;; ╠ ╡ ╢ ╣ ╤ ╥ ╦ ╧ ╨ ╩ ╪ ╫ ╬ ╭ ╮ ╯
-
-  ;; ╰ ╱ ╲ ╳ ╴ ╵ ╶ ╷ ╸ ╹ ╺ ╻ ╼ ╽ ╾ ╿
-
-  ;; Taken from https://en.wikipedia.org/wiki/Box_Drawing_(Unicode_block)
-
-  (let ((table1 (substring "
-╔══════╤══════╗
-║ text │ text ║
-╟──────┼──────╢
-║ text │ text ║
-╚══════╧══════╝
-"
-                           1))
-        (table2 (substring "
-╭──────┰──────╮
-│ text ┃ text │
-┝━━━━━━╋━━━━━━┥
-│ text ┃ text │
-╰──────┸──────╯
-"
-                           1)))
-
-    ;; In an application, especially one that where the content changes
-    ;; frequently, it would probably be better to determine whether all used
-    ;; table characters have equal width with letters once, and then use them or
-    ;; ASCII accordingly. This would be noticably faster.
-
-    (mb-table-insert table1)
-    (mb-table-insert table2)
-    ))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Quoted paragraph"
-  "The red line is drawn using text-properties, so the text can
-be copy-pasted with without extra spaces."
-  (let (( prefix (concat " "
-                         (propertize " "
-                                     'display '(space :width (4))
-                                     'face '(:background "DarkRed"))
-                         " ")))
-    (mb-insert-filled
-     (propertize "Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nunc
-porta vulputate tellus. Proin quam nisl, tincidunt et, mattis eget, convallis
-nec, purus. Nullam tempus. Pellentesque tristique imperdiet tortor. Lorem ipsum
-dolor sit amet, consectetuer adipiscing elit."
-                 'wrap-prefix prefix
-                 'line-prefix prefix
-                 'face 'italic))
-    ))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Fringe indicators"
-  (mb-insert-info-links
-   (info "(elisp) Fringe Indicators"))
-  (mb-comment "fringe-indicator-alist contains the default indicators. The easiest way to
-make new ones is to use an external package called `fringe-helper'.")
-  (insert "\n")
-  (let (( insert-fringe-bitmap
-          (lambda (symbol-name)
-            (insert (propertize " " 'display
-                                `((left-fringe ,symbol-name font-lock-comment-face)
-                                  (right-fringe ,symbol-name font-lock-comment-face)))))))
-    (cl-loop for pair in fringe-indicator-alist
-             for iter = 0 then (1+ iter)
-             do
-             (unless (zerop iter)
-               (insert "\n"))
-             (insert (propertize (concat "* " (symbol-name (car pair)))
-                                 'face 'info-title-4)
-                     "\n")
-             (if (symbolp (cdr pair))
-                 (progn
-                   (funcall insert-fringe-bitmap (cdr pair))
-                   (insert (concat "  " (symbol-name (cdr pair))) "\n"))
-                 (cl-dolist (bitmap (cdr pair))
-                   (progn
-                     (funcall insert-fringe-bitmap bitmap)
-                     (insert (concat "  " (symbol-name bitmap)) "\n"))))
-             )))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Pointer shapes"
-  (mb-insert-info-links
-   (info "(elisp) Pointer Shape"))
-  (mb-comment "Hover with your mouse over the labels to change the pointer.")
-  (insert "\n")
-  (mapc (lambda (pointer-sym)
-          (insert (propertize
-                   (symbol-name pointer-sym)
-                   'pointer pointer-sym
-                   'face '(:background "Purple"))
-                  "\n\n"))
-        '(text arrow hand vdrag hdrag modeline hourglass)))
-
-;; -----------------------------------------------------------------------------
-
-(mb-section "Images"
-  (mb-insert-info-links
-   (info "(elisp) Showing Images")
-   (info "(elisp) Image Descriptors"))
-  (mb-comment "Scrolling generally misbehaves with images. Presumably `insert-sliced-image'
-was made to improve the situation, but it makes things worse on occasion.")
-  (let (( image-size
-          ;; For terminal displays
-          (ignore-errors (image-size `(image :type jpeg
-                                             :file ,mb-expamle-image)))))
-    (mb-subsection-header "Simple case")
-    (insert-image `(image :type jpeg
-                          :file ,mb-expamle-image)
-                  "[you should be seeing an image]")
-    (insert "\n\n")
-    (when image-size
-      (mb-subsection-header "Using `insert-sliced-image'")
-      (insert-sliced-image `(image :type jpeg
-                                   :file ,mb-expamle-image)
-                           "[you should be seeing an image]"
-                           nil (car image-size))
-      (insert "\n"))
-    (mb-subsection-header "You can also crop images, or add a number of effects")
-    (insert-image `(image :type jpeg
-                          :file ,mb-expamle-image)
-                  "[you should be seeing an image]"
-                  nil '(60 25 100 150))
-    (insert " ")
-    (insert-image `(image :type jpeg
-                          :file ,mb-expamle-image
-                          :conversion disabled)
-                  "[you should be seeing an image]"
-                  nil '(60 25 100 150))))
-
-(mb-section "SVG"
-  "More complex effects can be achieved through SVG"
-  (mb-subsection-header "Resizing an masking")
-  ;; The link probably won't work on winodws
-  (let ((data (format "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"109\" height=\"150\">
-          <defs>
-          <clipPath id=\"circularPath\" clipPathUnits=\"objectBoundingBox\">
-          <circle cx=\"0.5\" cy=\"0.5\" r=\"0.5\"/>
-          </clipPath>
-          </defs>
-          <image id=\"image\" width=\"109\" height=\"150\" style=\"clip-path: url(#circularPath);\"
-          xlink:href=\"file://%s\" />
-          </svg>"
-                      mb-expamle-image)))
-    (insert-image `(image :type svg :data ,data)
-                  ))
-  (insert "\n\n")
-  (mb-subsection-header "Subjecting online images to multiplication and skewing")
-  (let ((data "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"400\" height=\"260\">
-  <image id=\"image\" x=\"10\" y=\"10\" width=\"100\" height=\"45\" transform=\"skewX(10)\"
-  xlink:href=\"http://www.gnu.org/graphics/behroze/behroze-gnu-button1.png\" />
-  <image id=\"image2\" x=\"50\" y=\"35\" width=\"200\" height=\"90\" transform=\"skewX(-10)\"
-  xlink:href=\"http://www.gnu.org/graphics/behroze/behroze-gnu-button1.png\" />
-  <image id=\"image2\" x=\"50\" y=\"100\" width=\"300\" height=\"135\" transform=\"skewX(10)\"
-  xlink:href=\"http://www.gnu.org/graphics/behroze/behroze-gnu-button1.png\" />
-  </svg>"
-              ))
-    (insert-image `(image :type svg :data ,data))))
-
-;; -----------------------------------------------------------------------------
-
-;; (mb-section "Widgets"
-;;   (insert-button "Click me" 'action
-;;                  (lambda (event)
-;;                    (message "Button clicked"))))
-
-;; -----------------------------------------------------------------------------
-
-;; (mb-section "Colors")
-
-;; -----------------------------------------------------------------------------
-
-(defun magic-buffer (&rest ignore)
-  (interactive)
-  (let ((buf (get-buffer-create "*magic-buffer*")))
-    (with-current-buffer buf
-      (let ((inhibit-read-only t))
-        (erase-buffer)
-        (fundamental-mode)
-        (progn
-          (setq truncate-lines nil)
-          (setq line-spacing 0)
-          (setq left-fringe-width 8
-                right-fringe-width 8))
-        (setq-local revert-buffer-function 'magic-buffer)
-        (insert (propertize "Magic buffer"
-                            'face 'info-title-2)
-                "\n")
-        (mb-insert-filled
-         (propertize "If you want to see the source, do `M-x find-function magic-buffer'"
-                     'face 'font-lock-comment-face))
-        (insert "\n\n")
-        (cl-dolist (section (if mb--exclusive-section
-                                (cl-remove-if-not
-                                 (apply-partially
-                                  '= mb--exclusive-section)
-                                 mb-sections
-                                 :key 'car)
-                                (cl-sort (cl-copy-list mb-sections)
-                                         '< :key 'car)))
-          (cl-destructuring-bind (number name doc function) section
-            (insert "\n\n")
-            (insert (propertize
-                     (format "%s. %s:\n" number name)
-                     'face 'info-title-3))
-            (if doc
-                (mb-insert-filled
-                 (propertize
-                  (format "%s\n\n" doc)
-                  'face 'font-lock-comment-face))
-                (insert "\n"))
-            (funcall function)
-            (goto-char (point-max))
-            (unless (zerop (current-column))
-              (insert "\n"))
-            (insert "\n"))))
-      (unless view-mode
-        (view-mode 1))
-      (goto-char (point-min)))
-    (switch-to-buffer buf)))
-
-(provide 'magic-buffer)
-
-;; Local Variables:
-;; truncate-lines: nil
-;; eval: (orgstruct-mode 1)
-;; orgstruct-heading-prefix-regexp: "^;;; \\*+"
-;; End:
-
-;;; magic-buffer.el ends here
diff --git i/_emacs.d/elisp/ninja-mode.el w/_emacs.d/elisp/ninja-mode.el
index e218f52..784df5f 100644
--- i/_emacs.d/elisp/ninja-mode.el
+++ w/_emacs.d/elisp/ninja-mode.el
@@ -1,20 +1,3 @@
-;; Copyright 2011 Google Inc. All Rights Reserved.
-;;
-;; Licensed under the Apache License, Version 2.0 (the "License");
-;; you may not use this file except in compliance with the License.
-;; You may obtain a copy of the License at
-;;
-;;     http://www.apache.org/licenses/LICENSE-2.0
-;;
-;; Unless required by applicable law or agreed to in writing, software
-;; distributed under the License is distributed on an "AS IS" BASIS,
-;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-;; See the License for the specific language governing permissions and
-;; limitations under the License.
-
-;; Simple emacs mode for editing .ninja files.
-;; Just some syntax highlighting for now.
-
 (defvar ninja-keywords)
 (setq ninja-keywords
       (list
diff --git i/_emacs.d/elisp/patch.el w/_emacs.d/elisp/patch.el
deleted file mode 100644
index c3488e6..0000000
--- i/_emacs.d/elisp/patch.el
+++ /dev/null
@@ -1,534 +0,0 @@
-;;; patch.el --- derived from hexl.el, hideif.el
-;;; Copyright 1997 Pavel Machek <pavel@atrey.karlin.mff.cuni.cz>
-;;; No warranty given, distribute according to GPL.
-
-;;; Code:
-
-;;; Place diffcvt into /usr/libexec/emacs/19.34/i486-linux/diffcvt (or
-;;; similar) directory *OR* place it anywhere else and edit patch-program
-;;; to ../../../../../../../where/you/placed/it/diffcvt.
-
-;;
-;; vars here
-;;
-
-                                        ; Hint: /../../../../../../../../../path/diffcvt may help
-(defvar patch-program "diffcvt"
-  "The program that will patchify and depatchify its stdin.
-`patch-program' will always be concatenated with `patch-options'
-and \"-de\" when depatchifying a buffer.")
-
-(defvar patchify-command
-  (format "%s%s" exec-directory patch-program)
-  "The command to use to patchify a buffer.")
-
-(defvar depatchify-command
-  (format "%s -d" patchify-command)
-  "The command to use to unpatchify a buffer.")
-
-(defvar patch-mode-map (make-sparse-keymap)
-  "Keymap for Patch mode.")
-
-(define-key patch-mode-map "\en" 'patch-next-hunk)
-(define-key patch-mode-map "\eN" 'patch-next-file)
-(define-key patch-mode-map "\ep" 'patch-prev-hunk)
-(define-key patch-mode-map "\eP" 'patch-prev-file)
-(define-key patch-mode-map "\ek" 'patch-kill-hunk)
-(define-key patch-mode-map "\eK" 'patch-kill-file)
-
-(defun patch-kill-hunk ()
-  "Kill current hunk."
-  (interactive)
-  (progn
-    (next-line 1)
-    (re-search-backward "^\\@\\@")
-    (setq killto (save-excursion
-                   (progn
-                     (next-line 1)
-                     (re-search-forward "^\\@\\@")
-                     (beginning-of-line)
-                     (point))))
-    (kill-region (point) killto)))
-
-(defun patch-kill-file ()
-  "Kill current file (or section corresponding to one file in patch)."
-  (interactive)
-  (progn
-    (next-line 1)
-    (re-search-backward "^--- ")
-    (setq killto (save-excursion
-                   (progn
-                     (next-line 1)
-                     (re-search-forward "^\\@\\@ EOF")
-                     (next-line 1)
-                     (beginning-of-line)
-                     (point))))
-    (kill-region (point) killto)))
-
-(defun patch-next-hunk ()
-  "Move to next hunk."
-  (interactive)
-  (prog1
-      (next-line 1)
-    (re-search-forward '"^\\@\\@")
-    (beginning-of-line)))
-
-(defun patch-prev-hunk ()
-  "Move to previous hunk."
-  (interactive)
-  (prog1
-      (next-line -1)
-    (re-search-backward '"^\\@\\@")
-    (beginning-of-line)))
-
-(defun patch-next-file ()
-  "Move to next file"
-  (interactive)
-  (prog1
-      (next-line 1)
-    (re-search-forward '"^---")
-    (beginning-of-line)))
-
-(defun patch-prev-file ()
-  "Move to preivous file"
-  (interactive)
-  (prog1
-      (next-line -1)
-    (re-search-backward '"^---")
-    (beginning-of-line)))
-
-;; routines
-
-;;;###autoload
-(defun patch-mode (&optional arg)
-  "This mode is intended for editing files generated by diff"
-  (interactive "p")
-  (if (eq major-mode 'patch-mode)
-      (error "You are already in patch mode")
-
-    (let ((modified (buffer-modified-p))
-          (inhibit-read-only t)
-          (original-point (1- (point))))
-      (patchify-buffer)
-      (set-buffer-modified-p modified))
-
-    (use-local-map patch-mode-map)
-
-    ;; Add hooks to repatchify or depatchify on various events.
-    (make-local-hook 'after-revert-hook)
-    (add-hook 'after-revert-hook 'patch-after-revert-hook nil t)
-
-    (add-hook 'write-contents-hooks 'patch-save-buffer)
-
-    (setq mode-name "Patch")
-    (setq major-mode 'patch-mode)
-
-    (progn
-                                        ; inherit global values
-      (make-local-variable 'patch-hiding)
-      (setq patch-hiding (default-value 'patch-hiding))
-
-      (run-hooks 'patch-mode-hook)
-
-      (if patch-initially
-          (hide-all-patchblocks)
-        (show-all-patchblocks))
-      (message "Enter Patch mode")
-      )
-
-    (make-local-hook 'change-major-mode-hook)
-    (add-hook 'change-major-mode-hook 'patch-maybe-depatchify-buffer nil t))
-  (run-hooks 'patch-mode-hook))
-
-(defun patch-after-revert-hook ()
-  (patchify-buffer)
-  (set-buffer-modified-p nil))
-
-(defvar patch-in-save-buffer nil)
-
-(defun patch-save-buffer ()
-  "Save a patch format buffer as binary in visited file if modified."
-  (interactive)
-  (message "(Saving under patch mode")
-  (if patch-in-save-buffer nil
-    (set-buffer-modified-p (if (buffer-modified-p)
-                               (save-excursion
-                                 (let ((buf (generate-new-buffer " patch"))
-                                       (name (buffer-name))
-                                       (file-name (buffer-file-name))
-                                       (start (point-min))
-                                       (end (point-max))
-                                       modified)
-                                   (set-buffer buf)
-                                   (insert-buffer-substring name start end)
-                                   (set-buffer name)
-                                   (depatchify-buffer)
-                                   ;; Prevent infinite recursion.
-                                   (let ((patch-in-save-buffer t)
-                                         (buffer-file-type t)) ; for ms-dos
-                                     (save-buffer))
-                                   (setq modified (buffer-modified-p))
-                                   (delete-region (point-min) (point-max))
-                                   (insert-buffer-substring buf start end)
-                                   (kill-buffer buf)
-                                   modified))
-                             (message "(No changes need to be saved)")
-                             nil))
-    ;; Return t to indicate we have saved t
-    t))
-
-(defun patch-maybe-depatchify-buffer ()
-  "Convert a patch format buffer to binary.
-Ask the user for confirmation."
-  (if (y-or-n-p "Convert contents back to binary format? ")
-      (let ((modified (buffer-modified-p))
-            (inhibit-read-only t))
-        (depatchify-buffer)
-        (remove-hook 'write-contents-hooks 'patch-save-buffer)
-        (set-buffer-modified-p modified))))
-
-;;;###autoload
-(defun patchify-buffer ()
-  "Convert a binary buffer to patch format.
-This discards the buffer's undo information."
-  (interactive)
-  (and buffer-undo-list
-       (or (y-or-n-p "Converting to patch format discards undo info; ok? ")
-           (error "Aborted")))
-  (setq buffer-undo-list nil)
-  (let ((binary-process-output nil) ; for Ms-Dos
-        (binary-process-input t)
-        (buffer-undo-list t))
-    (shell-command-on-region (point-min) (point-max) patchify-command t)))
-
-(defun depatchify-buffer ()
-  "Convert a patch format buffer to binary.
-This discards the buffer's undo information."
-  (interactive)
-  (and buffer-undo-list
-       (or (y-or-n-p "Converting from patch format discards undo info; ok? ")
-           (error "Aborted")))
-  (setq buffer-undo-list nil)
-  (let ((binary-process-output t) ; for Ms-Dos
-        (binary-process-input nil)
-        (buffer-undo-list t))
-    (shell-command-on-region (point-min) (point-max) depatchify-command t)))
-
-;;; Following is from hide-ifdef
-
-;; from outline.el with docstring fixed.
-(defun patchider-outline-flag-region (from to flag)
-  "Hides or shows lines from FROM to TO, according to FLAG.
-If FLAG is \\n (newline character) then text is shown, while if FLAG is \\^M
-\(control-M) the text is hidden."
-  (let ((modp (buffer-modified-p)))
-    (unwind-protect (progn
-                      (subst-char-in-region from to
-                                            (if (= flag ?\n) ?\^M ?\n)
-                                            flag t) )
-      (set-buffer-modified-p modp))
-    ))
-
-(defun patchider-show-all ()
-  "Show all of the text in the current buffer."
-  (interactive)
-  (patchider-outline-flag-region (point-min) (point-max) ?\n))
-
-;; By putting this on after-revert-hook, we arrange that it only
-;; does anything when revert-buffer avoids turning off the mode.
-;; (That can happen in VC.)
-(defun patchider-before-revert-function ()
-  (and (boundp 'patch-mode) patch-mode patch-hiding
-       (hide-all-patchblocks t)))
-(add-hook 'after-revert-hook 'patchider-before-revert-function)
-
-(defun patch-region (start end)
-  "START is the start of a #if or #else form.  END is the ending part.
-Everything including these lines is made invisible."
-  (patchider-outline-flag-region start end ?\^M)
-  )
-
-(defun patchider-show-ifdef-region (start end)
-  "Everything between START and END is made visible."
-  (patchider-outline-flag-region start end ?\n)
-  )
-
-
-                                        ;===%%SF%% parsing (Start)  ===
-;;;  The code that understands what ifs and ifdef in files look like.
-
-(defconst patchider-ifx-regexp "^--- ")
-(defconst patchider-endif-regexp "^\\@\\@ EOF")
-(defconst patchider-ifx-else-endif-regexp
-  (concat patchider-ifx-regexp "\\|" patchider-endif-regexp))
-
-(defun patchider-find-any-ifX ()
-  "Move to next #if..., or #ifndef, at point or after."
-                                        ;  (message "find ifX at %d" (point))
-  (prog1
-      (re-search-forward patchider-ifx-regexp (point-max) t)
-    (beginning-of-line)))
-
-(defun patchider-find-next-relevant ()
-  "Move to next #if..., #else, or #endif, after the current line."
-                                        ;  (message "patchider-find-next-relevant at %d" (point))
-  (end-of-line)
-                                        ; avoid infinite recursion by only going to beginning of line if match found
-  (if (re-search-forward patchider-ifx-else-endif-regexp (point-max) t)
-      (beginning-of-line)))
-
-(defun patchider-find-previous-relevant ()
-  "Move to previous #if..., #else, or #endif, before the current line."
-                                        ;  (message "patchider-find-previous-relevant at %d" (point))
-  (beginning-of-line)
-                                        ; avoid infinite recursion by only going to beginning of line if match found
-  (if (re-search-backward patchider-ifx-else-endif-regexp (point-min) t)
-      (beginning-of-line)))
-
-
-(defun patchider-looking-at-ifX ()              ;; Should eventually see #if
-  (looking-at patchider-ifx-regexp))
-(defun patchider-looking-at-endif ()
-  (looking-at patchider-endif-regexp))
-
-
-(defun patchider-ifdef-to-endif ()
-  "If positioned at #ifX or #else form, skip to corresponding #endif."
-                                        ;  (message "patchider-ifdef-to-endif at %d" (point)) (sit-for 1)
-  (patchider-find-next-relevant)
-  (cond ((patchider-looking-at-ifX)
-         (patchider-ifdef-to-endif) ; find endif of nested if
-         (patchider-ifdef-to-endif)) ; find outer endif or else
-        ((patchider-looking-at-endif)
-         'done)
-        (t
-         (error "Mismatched #ifdef #endif pair"))))
-
-(defun patchider-endif-to-ifdef ()
-  "If positioned at #endif form, skip backward to corresponding #ifX."
-                                        ;  (message "patchider-endif-to-ifdef at %d" (point))
-  (let ((start (point)))
-    (patchider-find-previous-relevant)
-    (if (= start (point))
-        (error "Mismatched #ifdef #endif pair")))
-  (cond ((patchider-looking-at-endif)
-         (patchider-endif-to-ifdef) ; find beginning of nested if
-         (patchider-endif-to-ifdef)) ; find beginning of outer if or else
-        ((patchider-looking-at-ifX)
-         'done)
-        (t)))                   ; never gets here
-
-
-(defun up-ifdef ()
-  "Move point to beginning of enclosing ifdef or else-part."
-  (interactive)
-  (beginning-of-line)
-  (let ((start (point)))
-    (if (not (patchider-looking-at-endif))
-        (patchider-find-previous-relevant))
-    (if (patchider-looking-at-endif)
-        (patchider-endif-to-ifdef))
-    (if (= start (point))
-        (error "No previous #ifdef"))))
-
-;;; A range is a structure with four components:
-;;; ELSE-P      True if there was an else clause for the ifdef.
-;;; START       The start of the range. (beginning of line)
-;;; ELSE        The else marker (beginning of line)
-;;;                     Only valid if ELSE-P is true.
-;;; END         The end of the range.  (beginning of line)
-
-(defun patchider-make-range (else-p start end &optional else)
-  (list else-p start else end))
-
-(defun patchider-range-else-p (range)  (elt range 0))
-(defun patchider-range-start (range) (elt range 1))
-(defun patchider-range-else (range) (elt range 2))
-(defun patchider-range-end (range) (elt range 3))
-
-
-
-;;; Find-Range
-;;; The workhorse, it delimits the #if region.  Reasonably simple:
-;;; Skip until an #else or #endif is found, remembering positions.  If
-;;; an #else was found, skip some more, looking for the true #endif.
-
-(defun patchider-find-range ()
-  "Returns a Range structure describing the current #if region.
-Point is left unchanged."
-                                        ;  (message "patchider-find-range at %d" (point))
-  (save-excursion
-    (beginning-of-line)
-    (let ((start (point))
-          (else-p nil)
-          (else nil)
-          (end nil))
-      ;; Part one.  Look for either #endif or #else.
-      ;; This loop-and-a-half dedicated to E. Dijkstra.
-      (patchider-find-next-relevant)
-      (while (patchider-looking-at-ifX)         ; Skip nested ifdef
-        (patchider-ifdef-to-endif)
-        (patchider-find-next-relevant))
-      ;; Found either a #else or an #endif.
-      (cond (t
-             (setq end (point)) ; (save-excursion (end-of-line) (point))
-             ))
-      ;; If found #else, look for #endif.
-      (if else-p
-          (progn
-            (patchider-find-next-relevant)
-            (while (patchider-looking-at-ifX)   ; Skip nested ifdef
-              (patchider-ifdef-to-endif)
-              (patchider-find-next-relevant))
-            (setq end (point))  ; (save-excursion (end-of-line) (point))
-            ))
-      (patchider-make-range else-p start end else))))
-
-
-;;; A bit slimy.
-;;; NOTE:  If there's an #ifdef at the beginning of the file, we can't
-;;; hide it.  There's no previous newline to replace.  If we added
-;;; one, we'd throw off all the counts.  Feh.
-
-(defun patchider-hide-line (point)
-  "Hide the line containing point.  Does nothing if `patch-lines' is nil."
-  (if patch-lines
-      (save-excursion
-        (goto-char point)
-        (let ((modp (buffer-modified-p)))
-          (unwind-protect
-              (progn
-                (beginning-of-line)
-                (if (not (= (point) 1))
-                    (patch-region (1- (point)) (point))))
-            (set-buffer-modified-p modp))
-          ))
-    ))
-
-(defun patchider-possibly-hide ()
-  "Called at #ifX expression, this hides those parts that should be hidden.
-It uses the judgement of `patch-evaluator'."
-                                        ;  (message "patchider-possibly-hide") (sit-for 1)
-  (let ((range (patchider-find-range)))
-                                        ;      (message "test = %s" test) (sit-for 1)
-
-    (patchider-hide-line (patchider-range-end range))
-    (patch-region (point)
-                  (1- (patchider-range-end range)))
-
-    (patchider-hide-line (patchider-range-start range))       ; Always hide start.
-    (goto-char (patchider-range-end range))
-    (end-of-line)
-    ))
-
-
-(defun patch-guts ()
-  "Does most of the work of `hide-all-patchblocks'.
-It does not do the work that's pointless to redo on a recursive entry."
-                                        ;  (message "patch-guts")
-  (save-excursion
-    (goto-char (point-min))
-    (while (patchider-find-any-ifX)
-      (patchider-possibly-hide))))
-
-;;;###autoload
-(defvar patch-initially nil
-  "*Non-nil means call `hide-all-patchblocks' when Patch mode is first activated.")
-
-;;;###autoload
-(defvar patch-read-only nil
-  "*Set to non-nil if you want buffer to be read-only while hiding text.")
-
-(defvar patchider-outside-read-only nil
-  "Internal variable.  Saves the value of `buffer-read-only' while hiding.")
-
-;;;###autoload
-(defvar patch-lines nil
-  "*Non-nil means hide the #ifX, #else, and #endif lines.")
-
-(defvar patch-hiding nil
-  "")
-
-(defun hide-all-patchblocks (&optional nomsg)
-  "Hide the contents of some #ifdefs.
-Assume that defined symbols have been added to `patch-env'.
-The text hidden is the text that would not be included by the C
-preprocessor if it were given the file with those symbols defined.
-
-Turn off hiding by calling `show-all-patchblocks'."
-
-  (interactive)
-  (message "Hiding...")
-  (setq patchider-outside-read-only buffer-read-only)
-  (if patch-hiding
-      (show-all-patchblocks))                   ; Otherwise, deep confusion.
-  (let ((inhibit-read-only t))
-    (setq selective-display t)
-    (setq patch-hiding t)
-    (patch-guts))
-  (setq buffer-read-only (or patch-read-only patchider-outside-read-only))
-  (or nomsg
-      (message "Hiding done")))
-
-
-(defun show-all-patchblocks ()
-  "Cancel the effects of `patch': show the contents of all #ifdefs."
-  (interactive)
-  (setq buffer-read-only patchider-outside-read-only)
-  (setq selective-display nil)  ; defaults
-  (let ((inhibit-read-only t))
-    (patchider-show-all))
-  (setq patch-hiding nil))
-
-
-(defun patchider-find-patchblock ()
-  "Utility for hide and show `patchblock'.
-Set top and bottom of patchblock."
-  (let (max-bottom)
-    (save-excursion
-      (beginning-of-line)
-      (if (not (patchider-looking-at-ifX))
-          (up-ifdef))
-      (setq top (point))
-      (patchider-ifdef-to-endif)
-      (setq max-bottom (1- (point))))
-    (save-excursion
-      (beginning-of-line)
-      (if (not (patchider-looking-at-endif))
-          (patchider-find-next-relevant))
-      (while (patchider-looking-at-ifX)
-        (patchider-ifdef-to-endif)
-        (patchider-find-next-relevant))
-      (setq bottom (min max-bottom (1- (point))))))
-  )
-
-
-(defun hide-patchblock ()
-  "Hide the patchblock (true or false part) enclosing or before the cursor."
-  (interactive)
-  (setq selective-display t)
-  (let (top bottom (inhibit-read-only t))
-    (patchider-find-patchblock) ; set top and bottom - dynamic scoping
-    (patch-region top bottom)
-    (if patch-lines
-        (progn
-          (patchider-hide-line top)
-          (patchider-hide-line (1+ bottom))))
-    (setq patch-hiding t))
-  (setq buffer-read-only (or patch-read-only patchider-outside-read-only)))
-
-
-(defun show-patchblock ()
-  "Show the patchblock (true or false part) enclosing or before the cursor."
-  (interactive)
-  (let ((inhibit-read-only t))
-    (if patch-lines
-        (save-excursion
-          (beginning-of-line)
-          (patchider-show-ifdef-region (1- (point)) (progn (end-of-line) (point))))
-
-      (let (top bottom)
-        (patchider-find-patchblock)
-        (patchider-show-ifdef-region (1- top) bottom)))))
-
-(provide 'patch-mode)
diff --git i/_emacs.d/elisp/youdao-dict.el w/_emacs.d/elisp/youdao-dict.el
index 12f19f4..6d2bde9 100644
--- i/_emacs.d/elisp/youdao-dict.el
+++ w/_emacs.d/elisp/youdao-dict.el
@@ -89,6 +89,7 @@
   (with-current-buffer (get-buffer-create youdao-return-xml) (erase-buffer))
   (call-process "curl" nil (list youdao-return-xml nil) nil (format search-url (url-hexify-string (read-word))))
   (pos-tip-show (youdao-dict-parse-xml) nil nil nil 0)
+  ;; (popup-tip (youdao-dict-parse-xml))
   (unwind-protect
       (push (read-event) unread-command-events)
     (pos-tip-hide))
